<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust UEFI Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tutorial/introduction.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/app.html"><strong aria-hidden="true">2.1.</strong> Creating a UEFI Application</a></li><li class="chapter-item expanded "><a href="tutorial/building.html"><strong aria-hidden="true">2.2.</strong> Building</a></li><li class="chapter-item expanded "><a href="tutorial/vm.html"><strong aria-hidden="true">2.3.</strong> Running in a VM</a></li><li class="chapter-item expanded "><a href="tutorial/hardware.html"><strong aria-hidden="true">2.4.</strong> Running on Hardware</a></li></ol></li><li class="chapter-item expanded "><a href="how_to/introduction.html"><strong aria-hidden="true">3.</strong> How-to</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="how_to/protocols.html"><strong aria-hidden="true">3.1.</strong> Using Protocols</a></li><li class="chapter-item expanded "><a href="how_to/drawing.html"><strong aria-hidden="true">3.2.</strong> Drawing to the Screen</a></li><li class="chapter-item expanded "><a href="how_to/building_drivers.html"><strong aria-hidden="true">3.3.</strong> Building drivers</a></li><li class="chapter-item expanded "><a href="how_to/rust-std.html"><strong aria-hidden="true">3.4.</strong> Combining Rust std with uefi</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/introduction.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/boot_stages.html"><strong aria-hidden="true">4.1.</strong> Boot Stages</a></li><li class="chapter-item expanded "><a href="concepts/tables.html"><strong aria-hidden="true">4.2.</strong> Tables</a></li><li class="chapter-item expanded "><a href="concepts/guid.html"><strong aria-hidden="true">4.3.</strong> GUID</a></li><li class="chapter-item expanded "><a href="concepts/handles_and_protocols.html"><strong aria-hidden="true">4.4.</strong> Handles and Protocols</a></li><li class="chapter-item expanded "><a href="concepts/device_paths.html"><strong aria-hidden="true">4.5.</strong> Device Paths</a></li><li class="chapter-item expanded "><a href="concepts/variables.html"><strong aria-hidden="true">4.6.</strong> Variables</a></li><li class="chapter-item expanded "><a href="concepts/gpt.html"><strong aria-hidden="true">4.7.</strong> GPT</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">5.</strong> Reference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust UEFI Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Rust UEFI Book. The focus of this book is how to use
<a href="https://github.com/rust-osdev/uefi-rs"><code>uefi-rs</code></a> to build UEFI applications in Rust, but it also describes
some general UEFI concepts, as well as relevant tools such as QEMU.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>This tutorial describes the process of creating and running a simple
x86_64 UEFI application in Rust. The application will print &quot;Hello
World&quot;, pause for 10 seconds, then exit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-uefi-application"><a class="header" href="#creating-a-uefi-application">Creating a UEFI application</a></h1>
<h2 id="install-dependencies"><a class="header" href="#install-dependencies">Install dependencies</a></h2>
<p>Follow the <a href="https://www.rust-lang.org/tools/install">Rust installation instructions</a> to set up Rust.</p>
<h2 id="create-a-minimal-application"><a class="header" href="#create-a-minimal-application">Create a minimal application</a></h2>
<p>Create an empty application and change to that directory:</p>
<pre><code class="language-sh">cargo new my-uefi-app
cd my-uefi-app
</code></pre>
<p>Add a few dependencies:</p>
<pre><code class="language-sh">cargo add log
cargo add uefi --features logger,panic_handler
</code></pre>
<p>to your <code>Cargo.toml</code>. The resulting <code>Cargo.toml</code> should look like that:</p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4&quot;
# Check crates.io for the latest version.
uefi = { version = &quot;&lt;latest, e.g. 0.36&gt;&quot;, features = [ &quot;panic_handler&quot;, &quot;logger&quot; ] }
</code></pre>
<p>Replace the contents of <code>src/main.rs</code> with this:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::time::Duration;
use log::info;
use uefi::prelude::*;

#[entry]
fn main() -&gt; Status {
    uefi::helpers::init().unwrap();
    info!(&quot;Hello world!&quot;);
    boot::stall(Duration::from_secs(10));
    Status::SUCCESS
}
</code></pre></pre>
<h2 id="walkthrough"><a class="header" href="#walkthrough">Walkthrough</a></h2>
<p>Let's look a quick look at what each part of the program is doing,
starting with the <code>#![...]</code> lines at the top:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_main]
#![no_std]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>This is some boilerplate that all Rust UEFI applications will
need. <code>no_main</code> is needed because the UEFI application entry point is
different from the standard Rust <code>main</code> function. <code>no_std</code> is needed to
turn off the <code>std</code> library; the <code>core</code> and <code>alloc</code> crates can still be
used.</p>
<p>Next up are some <code>use</code> lines. Nothing too exciting here; the
<code>uefi::prelude</code> module is intended to be glob-imported, and exports a
number of commonly-used macros, modules, and types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::time::Duration;
use log::info;
use uefi::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>Now we get to the UEFI application <code>main</code> function, and here things look
a little different from a standard Rust program.</p>
<pre><pre class="playground"><code class="language-rust">#[entry]
fn main() -&gt; Status {
</code></pre></pre>
<p>The <code>main</code> function in a UEFI application takes no arguments and returns
a <a href="https://docs.rs/uefi/latest/uefi/struct.Status.html"><code>Status</code></a>, which is essentially a numeric error (or success) code
defined by UEFI. The <code>main</code> function must be marked with the <code>#[entry]</code>
macro.</p>
<p>The first thing we do inside of <code>main</code> is initialize the <code>helpers</code>
module, which initializes logging:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    uefi::helpers::init().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Next we use the standard <code>log</code> crate to output &quot;Hello world!&quot;. Then we
call <code>stall</code> to make the system pause for 10 seconds. This just ensures
you have enough time to see the output.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    info!(&quot;Hello world!&quot;);
    boot::stall(Duration::from_secs(10));
<span class="boring">}
</span></code></pre></pre>
<p>Finally we return <code>Status::SUCCESS</code> indicating that everything completed
successfully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Status::SUCCESS
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building"><a class="header" href="#building">Building</a></h1>
<h2 id="toolchain"><a class="header" href="#toolchain">Toolchain</a></h2>
<p>In order to compile for UEFI, an appropriate target must be installed. The
easiest way to set this up is using a <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">rustup toolchain file</a>. In the root of
your repository, add <code>rust-toolchain.toml</code>:</p>
<pre><code class="language-toml">[toolchain]
targets = [&quot;aarch64-unknown-uefi&quot;, &quot;i686-unknown-uefi&quot;, &quot;x86_64-unknown-uefi&quot;]
</code></pre>
<p>Here we have specified all three of the currently-supported UEFI targets; you
can remove some if you don't need them.</p>
<h2 id="build-the-application"><a class="header" href="#build-the-application">Build the application</a></h2>
<p>Run this command to build the application:</p>
<pre><code class="language-sh">cargo build --target x86_64-unknown-uefi
</code></pre>
<p>This will produce an x86-64 executable:
<code>target/x86_64-unknown-uefi/debug/my-uefi-app.efi</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-in-a-vm"><a class="header" href="#running-in-a-vm">Running in a VM</a></h1>
<h2 id="install-dependencies-1"><a class="header" href="#install-dependencies-1">Install dependencies</a></h2>
<p>Two dependencies are needed: <a href="https://www.qemu.org">QEMU</a>, which implements the virtual
machine itself, and <a href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF</a>, which provides UEFI firmware that QEMU can
run.</p>
<p>The details of how to install QEMU and OVMF will vary depending on your
operating system.</p>
<p>Debian/Ubuntu:</p>
<pre><code class="language-sh">sudo apt-get install qemu ovmf
</code></pre>
<p>Fedora:</p>
<pre><code class="language-sh">sudo dnf install qemu-kvm edk2-ovmf
</code></pre>
<h3 id="firmware-files"><a class="header" href="#firmware-files">Firmware files</a></h3>
<p>The OVMF package provides two firmware files, one for the executable
code and one for variable storage. (The package may provide multiple
variations of these files; refer to the package's documentation for
details of the files it includes.)</p>
<p>For ease of access we'll copy the OVMF code and vars files to the
project directory. The location where OVMF is installed depends on your
operating system; for Debian, Ubuntu and Fedora the files are under
<code>/usr/share/OVMF</code>.</p>
<p>Copy the files to your project directory:</p>
<pre><code class="language-sh">cp /usr/share/OVMF/OVMF_CODE.fd .
cp /usr/share/OVMF/OVMF_VARS.fd .
</code></pre>
<h2 id="system-partition"><a class="header" href="#system-partition">System partition</a></h2>
<p>Now create a directory structure containing the executable to imitate a
<a href="tutorial/../concepts/gpt.html#system-partition">UEFI System Partition</a>:</p>
<pre><code class="language-sh">mkdir -p esp/efi/boot
cp target/x86_64-unknown-uefi/debug/my-uefi-app.efi esp/efi/boot/bootx64.efi
</code></pre>
<h2 id="launch-the-vm"><a class="header" href="#launch-the-vm">Launch the VM</a></h2>
<p>Now we can launch QEMU, using <a href="https://en.m.wikibooks.org/wiki/QEMU/Devices/Storage#Virtual_FAT_filesystem_(VVFAT)">VVFAT</a> to access the <code>esp</code> directory created above.</p>
<pre><code class="language-sh">qemu-system-x86_64 -enable-kvm \
    -drive if=pflash,format=raw,readonly=on,file=OVMF_CODE.fd \
    -drive if=pflash,format=raw,readonly=on,file=OVMF_VARS.fd \
    -drive format=raw,file=fat:rw:esp
</code></pre>
<p>A QEMU window should appear, and after a few seconds you should see the
log message:</p>
<pre><code class="language-text">[ INFO]:  src/main.rs@011: Hello world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-on-hardware"><a class="header" href="#running-on-hardware">Running on Hardware</a></h1>
<p>Prerequisite: To allow loading your unsigned binary on your personal machine,
<a href="https://en.wikipedia.org/wiki/UEFI#Secure_Boot">secure boot</a> needs to be disabled in the BIOS setup.</p>
<p>To run on real hardware you'll need a specially-prepared USB drive.</p>
<h2 id="preparation"><a class="header" href="#preparation">Preparation</a></h2>
<p>The general steps to prepare the drive are:</p>
<ol>
<li>Partition the drive using <a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GPT</a>.</li>
<li>Create a partition.</li>
<li>Set the partition type GUID to
<code>C12A7328-F81F-11D2-BA4B-00A0C93EC93B</code>. That marks it as an EFI
System partition. (On many UEFI implementations this is not strictly
necessary, see note below.)</li>
<li>Format the partition as <a href="https://en.wikipedia.org/wiki/File_Allocation_Table">FAT</a>.</li>
<li>Mount the partition.</li>
<li>Create the directory path <code>EFI/BOOT</code> on the partition. (FAT is case
insensitive, so capitalization doesn't matter.)</li>
<li>Copy your EFI application to a file under <code>EFI/BOOT</code>. The file name
is specific to the architecture. For example, on x86_64 the file name
must be <code>BOOTX64.EFI</code>. See the <a href="tutorial/../concepts/gpt.html#system-partition">boot files</a> table for other
architectures.</li>
</ol>
<p>The details of exactly how to do these steps will vary depending on your OS.</p>
<p>Note that most UEFI implementations do not strictly require GPT
partitioning or the EFI System partition GUID; they will look for any
FAT partition with the appropriate directory structure. This is not
required however; the UEFI Specification says &quot;UEFI implementations may
allow the use of conforming FAT partitions which do not use the ESP
GUID.&quot;</p>
<h3 id="example-on-linux"><a class="header" href="#example-on-linux">Example on Linux</a></h3>
<p><strong>Warning: these operations are destructive! Do not run these commands
on a disk if you care about the data it contains.</strong></p>
<pre><code class="language-sh"># Create the GPT, create a 9MB partition starting at 1MB, and set the
# partition type to EFI System.
sgdisk \
    --clear \
    --new=1:1M:10M \
    --typecode=1:C12A7328-F81F-11D2-BA4B-00A0C93EC93B \
    /path/to/disk

# Format the partition as FAT.
mkfs.fat /path/to/disk_partition

# Mount the partition.
mkdir esp
mount /path/to/disk_partition esp

# Create the boot directory.
mkdir esp/EFI/BOOT

# Copy in the boot executable.
cp /path/to/your-executable.efi esp/EFI/BOOT/BOOTX64.EFI
</code></pre>
<h2 id="booting-the-usb"><a class="header" href="#booting-the-usb">Booting the USB</a></h2>
<p>Insert the USB into the target computer. Reboot the machine, then press
the one-time boot key. Which key to press depends on the vendor. For
example, Dell uses F12, HP uses F9, and on Macs you hold down the Option
key.</p>
<p>Once the one-time boot menu appears, select your USB drive and press enter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to"><a class="header" href="#how-to">How-to</a></h1>
<p>This chapter contains practical how-to guides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-protocols"><a class="header" href="#using-protocols">Using Protocols</a></h1>
<h2 id="about-uefi-protocols"><a class="header" href="#about-uefi-protocols">About UEFI Protocols</a></h2>
<p>UEFI protocols are a structured collection of functions and/or data. Please
head to the module documentation in <a href="https://docs.rs/uefi/latest/uefi/proto/index.html">uefi</a> for more technical information.</p>
<h2 id="usage-in-uefi-rs"><a class="header" href="#usage-in-uefi-rs">Usage in uefi-rs</a></h2>
<p>To open a protocol, you must first get a handle, then open a protocol
on that handle. See <a href="how_to/../concepts/handles_and_protocols.html">Handles and Protocols</a> for an overview of what
these terms mean.</p>
<p>To get a handle you can use:</p>
<ul>
<li><a href="https://docs.rs/uefi/latest/uefi/boot/fn.locate_handle_buffer.html"><code>boot::locate_handle_buffer</code></a>: this can be used to get <em>all</em>
available handles, or just the handles that support a particular
protocol.</li>
<li><a href="https://docs.rs/uefi/latest/uefi/boot/fn.locate_handle.html"><code>boot::locate_handle</code></a>: the same as <code>locate_handle_buffer</code>,
but you provide the slice that stores the handles.</li>
<li><a href="https://docs.rs/uefi/latest/uefi/boot/fn.locate_device_path.html"><code>boot::locate_device_path</code></a>: find a handle by <a href="how_to/../concepts/device_paths.html">Device Path</a>.</li>
</ul>
<p>Once you have obtained a handle, use
<a href="https://docs.rs/uefi/latest/uefi/boot/fn.open_protocol_exclusive.html"><code>boot::open_protocol_exclusive</code></a> to open a protocol on that
handle. This returns a <a href="https://docs.rs/uefi/latest/uefi/boot/struct.ScopedProtocol.html"><code>ScopedProtocol</code></a>, which automatically closes
the protocol when dropped.</p>
<p>Using <a href="https://docs.rs/uefi/latest/uefi/boot/fn.open_protocol_exclusive.html"><code>boot::open_protocol_exclusive</code></a> is the safest way to
open a protocol, but in some cases a protocol cannot be opened in
exclusive mode. The <code>unsafe</code> <a href="https://docs.rs/uefi/latest/uefi/boot/fn.open_protocol.html"><code>boot::open_protocol</code></a> can be used
in that case.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>For this example we'll look at a program that opens a couple different
protocols. This program opens the <a href="https://docs.rs/uefi/latest/uefi/proto/loaded_image/struct.LoadedImage.html"><code>LoadedImage</code></a> protocol to get
information about an executable (the currently-running program in this
case). It also opens the <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/text/struct.DevicePathToText.html"><code>DevicePathToText</code></a> protocol to get the file
system path that the program was launched from.</p>
<p>We'll walk through the details of this program shortly, but first here's
the whole thing:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use core::time::Duration;
use log::info;
use uefi::boot::{self, SearchType};
use uefi::prelude::*;
use uefi::proto::device_path::text::{
    AllowShortcuts, DevicePathToText, DisplayOnly,
};
use uefi::proto::loaded_image::LoadedImage;
use uefi::{Identify, Result};

#[entry]
fn main() -&gt; Status {
    uefi::helpers::init().unwrap();

    print_image_path().unwrap();

    boot::stall(Duration::from_secs(10));
    Status::SUCCESS
}

fn print_image_path() -&gt; Result {
    let loaded_image =
        boot::open_protocol_exclusive::&lt;LoadedImage&gt;(boot::image_handle())?;

    let device_path_to_text_handle = *boot::locate_handle_buffer(
        SearchType::ByProtocol(&amp;DevicePathToText::GUID),
    )?
    .first()
    .expect(&quot;DevicePathToText is missing&quot;);

    let device_path_to_text = boot::open_protocol_exclusive::&lt;DevicePathToText&gt;(
        device_path_to_text_handle,
    )?;

    let image_device_path =
        loaded_image.file_path().expect(&quot;File path is not set&quot;);
    let image_device_path_text = device_path_to_text
        .convert_device_path_to_text(
            image_device_path,
            DisplayOnly(true),
            AllowShortcuts(false),
        )
        .expect(&quot;convert_device_path_to_text failed&quot;);

    info!(&quot;Image path: {}&quot;, &amp;*image_device_path_text);
    Ok(())
}
</code></pre></pre>
<p>When the program is run it will print something like this:</p>
<pre><code class="language-text">[ INFO]: example.rs@058: Image path: \EFI\BOOT\BOOTX64.EFI
</code></pre>
<h2 id="walkthrough-1"><a class="header" href="#walkthrough-1">Walkthrough</a></h2>
<p>The <code>main</code> function looks much like the <a href="how_to/../tutorial/app.html">&quot;Hello world!&quot; example</a>. It
sets up logging, calls <code>print_image_path</code>, and pauses for ten seconds to
give you time to read the output. Let's look at <code>print_image_path</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_image_path() -&gt; Result {
<span class="boring">}
</span></code></pre></pre>
<p>The return type is a <a href="https://docs.rs/uefi/latest/uefi/type.Result.html"><code>uefi::Result</code></a>, which is a <code>Result</code> alias that
combines <a href="https://docs.rs/uefi/latest/uefi/struct.Status.html"><code>uefi::Status</code></a> with the error data. Both the success and
error data types are <code>()</code> by default.</p>
<p>The function starts by opening the <a href="https://docs.rs/uefi/latest/uefi/proto/loaded_image/struct.LoadedImage.html"><code>LoadedImage</code></a> protocol:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let loaded_image =
        boot::open_protocol_exclusive::&lt;LoadedImage&gt;(boot::image_handle())?;
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://docs.rs/uefi/latest/uefi/boot/fn.open_protocol_exclusive.html"><code>boot::open_protocol_exclusive</code></a> method takes a type parameter, which is
the type of <a href="https://docs.rs/uefi/latest/uefi/proto/trait.Protocol.html"><code>Protocol</code></a> you want to open (<a href="https://docs.rs/uefi/latest/uefi/proto/loaded_image/struct.LoadedImage.html"><code>LoadedImage</code></a> in this
case). It also takes one regular argument of type <a href="https://docs.rs/uefi/latest/uefi/data_types/struct.Handle.html"><code>Handle</code></a>. For this
example we want the handle of the currently-running image, conveniently
accessible through <a href="https://docs.rs/uefi/latest/uefi/boot/fn.image_handle.html"><code>boot::image_handle</code></a>.</p>
<p>Next the program opens the <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/text/struct.DevicePathToText.html"><code>DevicePathToText</code></a> protocol:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let device_path_to_text_handle = *boot::locate_handle_buffer(
        SearchType::ByProtocol(&amp;DevicePathToText::GUID),
    )?
    .first()
    .expect(&quot;DevicePathToText is missing&quot;);

    let device_path_to_text = boot::open_protocol_exclusive::&lt;DevicePathToText&gt;(
        device_path_to_text_handle,
    )?;
<span class="boring">}
</span></code></pre></pre>
<p>This protocol isn't available for the <code>image_handle</code>, so we start by
using <a href="https://docs.rs/uefi/latest/uefi/boot/fn.locate_handle_buffer.html"><code>boot::locate_handle_buffer</code></a> to find all handles that support
<code>DevicePathToText</code>. We only need one handle though, so we call <code>first()</code>
and discard the rest. Then we call <a href="https://docs.rs/uefi/latest/uefi/boot/fn.open_protocol_exclusive.html"><code>boot::open_protocol_exclusive</code></a> again. It
looks more or less like the previous time, but with <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/text/struct.DevicePathToText.html"><code>DevicePathToText</code></a>
as the type parameter and <code>device_path_to_text_handle</code> as the handle.</p>
<p>Now that we have both protocols open, we can use them together to get
the program's path and convert it to text:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let image_device_path =
        loaded_image.file_path().expect(&quot;File path is not set&quot;);
    let image_device_path_text = device_path_to_text
        .convert_device_path_to_text(
            image_device_path,
            DisplayOnly(true),
            AllowShortcuts(false),
        )
        .expect(&quot;convert_device_path_to_text failed&quot;);

    info!(&quot;Image path: {}&quot;, &amp;*image_device_path_text);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Since protocols do a wide range of different things, the methods
available to call are very specific to each individual protocol. The
best places to find out what each protocol can do are the <a href="https://docs.rs/uefi/latest/uefi/proto/index.html">uefi-rs
reference documentation</a> and the <a href="https://uefi.org/specifications">UEFI Specification</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-to-the-screen"><a class="header" href="#drawing-to-the-screen">Drawing to the Screen</a></h1>
<p>This example shows how to draw to the screen using the <a href="https://docs.rs/uefi/latest/uefi/proto/console/gop/index.html">graphics output protocol</a>.
The code will a <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle#Chaos_game">Sierpiński triangle</a> using the &quot;chaos game&quot; method.</p>
<p><img src="https://i.imgur.com/0tpjtV6.png" alt="screenshot" /></p>
<p>The core abstraction used here is a linear buffer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Buffer {
    width: usize,
    height: usize,
    pixels: Vec&lt;BltPixel&gt;,
}

impl Buffer {
    /// Create a new `Buffer`.
    fn new(width: usize, height: usize) -&gt; Self {
        Buffer {
            width,
            height,
            pixels: vec![BltPixel::new(0, 0, 0); width * height],
        }
    }

    /// Get a single pixel.
    fn pixel(&amp;mut self, x: usize, y: usize) -&gt; Option&lt;&amp;mut BltPixel&gt; {
        self.pixels.get_mut(y * self.width + x)
    }

    /// Blit the buffer to the framebuffer.
    fn blit(&amp;self, gop: &amp;mut GraphicsOutput) -&gt; Result {
        gop.blt(BltOp::BufferToVideo {
            buffer: &amp;self.pixels,
            src: BltRegion::Full,
            dest: (0, 0),
            dims: (self.width, self.height),
        })
    }

    /// Update only a pixel to the framebuffer.
    fn blit_pixel(
        &amp;self,
        gop: &amp;mut GraphicsOutput,
        coords: (usize, usize),
    ) -&gt; Result {
        gop.blt(BltOp::BufferToVideo {
            buffer: &amp;self.pixels,
            src: BltRegion::SubRectangle {
                coords,
                px_stride: self.width,
            },
            dest: coords,
            dims: (1, 1),
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This <code>Buffer</code> type stores a <code>Vec</code> of <a href="https://docs.rs/uefi/latest/uefi/proto/console/gop/struct.BltPixel.html"><code>BltPixel</code></a>s, which are BGRX
32-bit pixels (8 bites each for blue, green, and red, followed by 8
unused bits of padding). We use the <code>pixel</code> method to alter a single
pixel at a time. This is often not an efficient method; for more complex
graphics you could use a crate like <a href="https://crates.io/crates/embedded-graphics"><code>embedded-graphics</code></a>.</p>
<p>The <code>Buffer::blit</code> method calls the graphics output protocol's <code>blt</code>
method to copy the buffer to the screen.</p>
<p>Most of the rest of the code is just implementing the algorithm for
drawing the fractal. Here's the full example:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

extern crate alloc;

use alloc::vec;
use alloc::vec::Vec;
use uefi::prelude::*;
use uefi::proto::console::gop::{BltOp, BltPixel, BltRegion, GraphicsOutput};
use uefi::proto::rng::Rng;
use uefi::{Result, boot};

#[derive(Clone, Copy)]
struct Point {
    x: f32,
    y: f32,
}

impl Point {
    fn new(x: f32, y: f32) -&gt; Self {
        Self { x, y }
    }
}

struct Buffer {
    width: usize,
    height: usize,
    pixels: Vec&lt;BltPixel&gt;,
}

impl Buffer {
    /// Create a new `Buffer`.
    fn new(width: usize, height: usize) -&gt; Self {
        Buffer {
            width,
            height,
            pixels: vec![BltPixel::new(0, 0, 0); width * height],
        }
    }

    /// Get a single pixel.
    fn pixel(&amp;mut self, x: usize, y: usize) -&gt; Option&lt;&amp;mut BltPixel&gt; {
        self.pixels.get_mut(y * self.width + x)
    }

    /// Blit the buffer to the framebuffer.
    fn blit(&amp;self, gop: &amp;mut GraphicsOutput) -&gt; Result {
        gop.blt(BltOp::BufferToVideo {
            buffer: &amp;self.pixels,
            src: BltRegion::Full,
            dest: (0, 0),
            dims: (self.width, self.height),
        })
    }

    /// Update only a pixel to the framebuffer.
    fn blit_pixel(
        &amp;self,
        gop: &amp;mut GraphicsOutput,
        coords: (usize, usize),
    ) -&gt; Result {
        gop.blt(BltOp::BufferToVideo {
            buffer: &amp;self.pixels,
            src: BltRegion::SubRectangle {
                coords,
                px_stride: self.width,
            },
            dest: coords,
            dims: (1, 1),
        })
    }
}

/// Get a random `usize` value.
fn get_random_usize(rng: &amp;mut Rng) -&gt; usize {
    let mut buf = [0; size_of::&lt;usize&gt;()];
    rng.get_rng(None, &amp;mut buf).expect(&quot;get_rng failed&quot;);
    usize::from_le_bytes(buf)
}

fn draw_sierpinski() -&gt; Result {
    // Open graphics output protocol.
    let gop_handle = boot::get_handle_for_protocol::&lt;GraphicsOutput&gt;()?;
    let mut gop = boot::open_protocol_exclusive::&lt;GraphicsOutput&gt;(gop_handle)?;

    // Open random number generator protocol.
    let rng_handle = boot::get_handle_for_protocol::&lt;Rng&gt;()?;
    let mut rng = boot::open_protocol_exclusive::&lt;Rng&gt;(rng_handle)?;

    // Create a buffer to draw into.
    let (width, height) = gop.current_mode_info().resolution();
    let mut buffer = Buffer::new(width, height);

    // Initialize the buffer with a simple gradient background.
    for y in 0..height {
        let r = ((y as f32) / ((height - 1) as f32)) * 255.0;
        for x in 0..width {
            let g = ((x as f32) / ((width - 1) as f32)) * 255.0;
            let pixel = buffer.pixel(x, y).unwrap();
            pixel.red = r as u8;
            pixel.green = g as u8;
            pixel.blue = 255;
        }
    }

    // Draw background.
    buffer.blit(&amp;mut gop)?;

    let size = Point::new(width as f32, height as f32);

    // Define the vertices of a big triangle.
    let border = 20.0;
    let triangle = [
        Point::new(size.x / 2.0, border),
        Point::new(border, size.y - border),
        Point::new(size.x - border, size.y - border),
    ];

    // `p` is the point to draw. Start at the center of the triangle.
    let mut p = Point::new(size.x / 2.0, size.y / 2.0);

    // Loop forever, drawing the frame after each new point is changed.
    loop {
        // Choose one of the triangle's vertices at random.
        let v = triangle[get_random_usize(&amp;mut rng) % 3];

        // Move `p` halfway to the chosen vertex.
        p.x = (p.x + v.x) * 0.5;
        p.y = (p.y + v.y) * 0.5;

        // Set `p` to black.
        let pixel = buffer.pixel(p.x as usize, p.y as usize).unwrap();
        pixel.red = 0;
        pixel.green = 100;
        pixel.blue = 0;

        // Draw the buffer to the screen.
        buffer.blit_pixel(&amp;mut gop, (p.x as usize, p.y as usize))?;
    }
}

#[entry]
fn main() -&gt; Status {
    uefi::helpers::init().unwrap();
    draw_sierpinski().unwrap();
    Status::SUCCESS
}
</code></pre></pre>
<p>You can run this example from the <a href="https://github.com/rust-osdev/uefi-rs">uefi-rs</a> repository with:</p>
<pre><code class="language-console">cargo xtask run --example sierpinski
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-drivers"><a class="header" href="#building-drivers">Building drivers</a></h1>
<p>There are <a href="https://uefi.org/specs/UEFI/2.10/02_Overview.html#uefi-images">three types</a> of UEFI images:</p>
<ul>
<li>Application</li>
<li>Boot service driver</li>
<li>Runtime driver</li>
</ul>
<p><a href="https://github.com/rust-lang/rust/blob/f4d794ea0b845413344621d89f6c945062748485/compiler/rustc_target/src/spec/base/uefi_msvc.rs#L33">By default</a>, Rust's UEFI targets produce applications. This can be
changed by passing a <a href="https://learn.microsoft.com/en-us/cpp/build/reference/subsystem?view=msvc-170"><code>subsystem</code></a> linker flag in <code>rustflags</code> and setting the
value to <code>efi_boot_service_driver</code> or <code>efi_runtime_driver</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">// In build.rs

fn main() {
    let target = std::env::var(&quot;TARGET&quot;).unwrap();
    if target.ends_with(&quot;-unknown-uefi&quot;) {
        println!(&quot;cargo::rustc-link-arg=/subsystem:efi_runtime_driver&quot;);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combining-rust-std-with-uefi"><a class="header" href="#combining-rust-std-with-uefi">Combining Rust <code>std</code> with <code>uefi</code></a></h1>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p>In Mid-2024, we recommend to stick to our normal guide. Use this document as
guide and outlook for the future of UEFI and Rust.</p>
<h2 id="about"><a class="header" href="#about">About</a></h2>
<p>Programs created with the <code>uefi</code> crate are typically created with <code>#![no_std]</code>
and <code>#![no_main]</code>. A <code>#![no_std]</code> crate can use the <code>core</code> and <code>alloc</code> parts of
Rust's standard library, but not <code>std</code>. A <code>#![no_main]</code> executable does not use
the standard main entry point, and must define its own entry point; <code>uefi</code>
provides the <code>#[entry]</code> macro for this purpose.</p>
<p>Rust has added partial support for building UEFI executables without
<code>#![no_std]</code> and <code>#![no_main]</code>, thus, the standard way. Some functionality
requires a nightly toolchain, they are gated by the <code>uefi_std</code> feature (Rust
language feature, not <code>uefi</code> crate feature). Follow the
<a href="https://github.com/rust-lang/rust/issues/100499">tracking issue</a> for details.</p>
<h2 id="code-example"><a class="header" href="#code-example">Code Example</a></h2>
<p>Please refer to <a href="how_to//uefi-std-example/README.html"><code>&lt;repo&gt;/uefi-std-example</code></a> to
see a specific example. The relevant <code>main.rs</code> looks as follows:</p>
<pre><pre class="playground"><code class="language-rust">// Note: In Rust 1.82.0-nightly and before, the `uefi_std` feature is
// required for accessing `std::os::uefi::env::*`. The other default
// functionality doesn't need a nightly toolchain (with Rust 1.80 and later),
// but with that limited functionality you - currently - also can't integrate
// the `uefi` crate.
#![feature(uefi_std)]

use std::os::uefi as uefi_std;
use uefi::runtime::ResetType;
use uefi::{Handle, Status};

/// Performs the necessary setup code for the `uefi` crate.
fn setup_uefi_crate() {
    let st = uefi_std::env::system_table();
    let ih = uefi_std::env::image_handle();

    // Mandatory setup code for `uefi` crate.
    unsafe {
        uefi::table::set_system_table(st.as_ptr().cast());

        let ih = Handle::from_ptr(ih.as_ptr().cast()).unwrap();
        uefi::boot::set_image_handle(ih);
    }
}

fn main() {
    println!(&quot;Hello World from uefi_std&quot;);
    setup_uefi_crate();
    println!(&quot;UEFI-Version is {}&quot;, uefi::system::uefi_revision());
    uefi::runtime::reset(ResetType::SHUTDOWN, Status::SUCCESS, None);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>The canonical source of information about UEFI is the <a href="https://uefi.org/specifications">UEFI specification</a>.
The specification is huge (currently nearly 2500 pages). Much of that
content relates to optional services, understanding of which is not
critical to understanding UEFI as a whole. This chapter summarizes some
of the more important UEFI concepts and links to the relevant <code>uefi-rs</code>
documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boot-stages"><a class="header" href="#boot-stages">Boot Stages</a></h1>
<p>A UEFI system goes through several distinct phases during the boot process.</p>
<ol>
<li><strong>Platform Initialization.</strong> This early-boot phase is mostly outside
the scope of the <code>uefi</code> crate. It is described by the <a href="https://uefi.org/specifications">UEFI Platform
Initialization Specification</a>, which is separate from the main UEFI
Specification.</li>
<li><strong>Boot Services.</strong> This is when UEFI drivers and applications are loaded.
Functions in both the <a href="https://docs.rs/uefi/latest/uefi/boot/index.html"><code>boot</code></a> module and <a href="https://docs.rs/uefi/latest/uefi/runtime/index.html"><code>runtime</code></a> module can be used.
This stage typically culminates in running a bootloader that loads an
operating system. The stage ends when <a href="https://docs.rs/uefi/latest/uefi/boot/fn.exit_boot_services.html"><code>boot::exit_boot_services</code></a> is called,
putting the system in Runtime mode.</li>
<li><strong>Runtime.</strong> This stage is typically active when running an operating system
such as Linux or Windows. UEFI functionality is much more limited in the
Runtime mode. Functions in the <a href="https://docs.rs/uefi/latest/uefi/boot/index.html"><code>boot</code></a> module can no longer be used, but
functions in the <a href="https://docs.rs/uefi/latest/uefi/runtime/index.html"><code>runtime</code></a> module are still available. Once the system is
in Runtime mode, it cannot return to the Boot Services stage until after a
system reset.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tables"><a class="header" href="#tables">Tables</a></h1>
<p>UEFI has a few table structures. These tables are how you get access to UEFI
services. In the specification and C API, <code>EFI_SYSTEM_TABLE</code> is the top-level
table that provides access to the other tables, <code>EFI_BOOT_SERVICES</code> and
<code>EFI_RUNTIME_SERVICES</code>.</p>
<p>In the <code>uefi</code> crate, these tables are modeled as modules rather than structs. The
functions in each module make use of a global pointer to the system table that
is set automatically by the <a href="https://docs.rs/uefi/latest/uefi/attr.entry.html"><code>entry</code></a> macro.</p>
<ul>
<li>
<p><a href="https://docs.rs/uefi/latest/uefi/system/index.html"><code>uefi::system</code></a> (<code>EFI_SYSTEM_TABLE</code> in the specification) provides access to
system information such as the firmware vendor and version. It can also be used
to access stdout/stderr/stdin.</p>
</li>
<li>
<p><a href="https://docs.rs/uefi/latest/uefi/boot/index.html"><code>uefi::boot</code></a> (<code>EFI_BOOT_SERVICES</code> in the specification) provides access to a
wide array of services such as memory allocation, executable loading, and
optional extension interfaces called protocols. Functions in this module can
only be used while in the Boot Services stage. After <a href="https://docs.rs/uefi/latest/uefi/boot/fn.exit_boot_services.html"><code>exit_boot_services</code></a> has
been called, these functions will panic.</p>
</li>
<li>
<p><a href="https://docs.rs/uefi/latest/uefi/runtime/index.html"><code>uefi::runtime</code></a> (<code>EFI_RUNTIME_SERVICES</code> in the specification) provides access
to a fairly limited set of services, including variable storage, system time,
and virtual-memory mapping. Functions in this module are accessible during both
the Boot Services and Runtime stages.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guid"><a class="header" href="#guid">GUID</a></h1>
<p>GUID is short for Globally Unique Identifier. A GUID is always 16 bytes,
and has a standard string representation format that looks like this:
<code>313b0d7c-fed4-4de7-99ed-2fe48874a410</code>. The details of the GUID format
aren't too important, but be aware that the actual byte representation
is not in the same order as the string representation because the first
three fields are little-endian. For the most part you can treat GUIDs as
opaque identifiers.</p>
<p>The UEFI specification uses GUIDs all over the place. GUIDs are used to
identify protocols, disk partitions, variable groupings, and much
more. In <code>uefi-rs</code>, GUIDs are represented by the <a href="https://docs.rs/uefi/latest/uefi/struct.Guid.html"><code>Guid</code></a> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handles-and-protocols"><a class="header" href="#handles-and-protocols">Handles and Protocols</a></h1>
<p>Handles and protocols are at the core of what makes UEFI
extensible. Together they are the mechanism by which UEFI can adapt to a
wide array of hardware and boot conditions, while still providing a
consistent interface to drivers and applications.</p>
<h3 id="handles"><a class="header" href="#handles">Handles</a></h3>
<p>Handles represent resources. A resource might be a physical device such
as a disk drive or USB device, or something less tangible like a loaded
executable. </p>
<p>A <a href="https://docs.rs/uefi/latest/uefi/data_types/struct.Handle.html">Handle</a> is an opaque pointer, so you can't do anything with it
directly. To operate on a handle you have to open a protocol. </p>
<h3 id="protocols"><a class="header" href="#protocols">Protocols</a></h3>
<p>Protocols are interfaces that provide functions to interact with a
resource. For example, the <a href="https://docs.rs/uefi/latest/uefi/proto/media/block/struct.BlockIO.html">BlockIO</a> protocol provides functions to read
and write to block IO devices.</p>
<p>Protocols are only available during the Boot Services <a href="concepts/boot_stages.html">stage</a>; you can't
access them during the Runtime stage.</p>
<p>The UEFI Specification defines a very large number of protocols. Because
protocols are inherently very diverse, the best place to learn about
individual protocols is the <a href="https://uefi.org/specifications">UEFI Specification</a>. There are many
chapters covering various protocols. Not all of these protocols are
wrapped by <code>uefi-rs</code> yet (contributions welcome!) but many of the most
commonly useful ones are.</p>
<p>See the <a href="concepts/../how_to/protocols.html">Using Protocols</a> how-to for details of the <code>uefi-rs</code> API for
interacting with protocols.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-paths"><a class="header" href="#device-paths">Device Paths</a></h1>
<p>A device path is a very flexible packed data structure for storing paths
to many kinds of device. Note that these device paths are not the same
thing as file system paths, although they can include file system
paths. Like <a href="concepts/handles_and_protocols.html">handles</a>, device paths can be used to uniquely identify
resources such as consoles, mice, disks, partitions, and more. Unlike
<a href="concepts/handles_and_protocols.html">handles</a>, which are essentially opaque pointers, device paths are
variable-length structures that contain parseable information.</p>
<p>The <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/index.html"><code>uefi::proto::device_path</code></a> module documentation describes the
details of how device paths are encoded.</p>
<p>Device paths can also be converted to and from human-readable text
representations that look like this:</p>
<pre><code class="language-text">PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)
</code></pre>
<p>See <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/text/index.html"><code>uefi::proto::device_path::text</code></a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>UEFI provides fairly flexible key/value variable storage.</p>
<p>Each variable is identified by a key consisting of a UCS-2
null-terminated name plus a vendor <a href="concepts/guid.html">GUID</a>. The vendor GUID serves as a
namespace for variables so that different vendors don't accidentally
overwrite or misinterpret another vendor's variable if they happen to
have the same name.</p>
<p>The data stored in each variable is an arbitrary byte array.</p>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<p>Each variable has attributes (represented as bit flags) associated with
it that affect how it is stored and how it can be accessed.</p>
<p>If the <code>BOOTSERVICE_ACCESS</code> and <code>RUNTIME_ACCESS</code> bits are set, the
variable can be accessed during both the Boot Services and Runtime
<a href="concepts/boot_stages.html">stages</a>. If only <code>BOOTSERVICE_ACCESS</code> is set then the variable can
neither be read nor written to after exiting boot services.</p>
<p>Another important attribute is the <code>NON_VOLATILE</code> bit. If this bit is
<em>not</em> set, the variable will be stored in normal memory and will not
persist across a power cycle. If this bit <em>is</em> set, the variable will be
stored in special non-volatile memory. You should be careful about
writing variables of this type, because the non-volatile storage can be
very limited in size. There have been cases where a vendor's poor UEFI
implementation caused the machine not too boot once the storage became
too full. Even figuring out how much space is in use can be tricky due
to deletion being implemented via garbage collection. Matthew Garret's
article <a href="https://mjg59.dreamwidth.org/25091.html">&quot;Dealing with UEFI non-volatile memory quirks&quot;</a> has more details.</p>
<p>Most of the other attributes relate to authenticated variables, which
can be used to prevent changes to a variable by unauthorized programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gpt"><a class="header" href="#gpt">GPT</a></h1>
<p><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GPT</a> is short for <a href="concepts/guid.html">GUID</a> Partition Table. It's a more modern
alternative to MBR (master boot record) partition tables. Although it's
defined in the UEFI specification, it often gets used on non-UEFI
systems too. There are a couple big advantages of using GPT over MBR:</p>
<ul>
<li>It has a relatively clear and precise standard, unlike MBR where
implementations often just try to match what other implementations do.</li>
<li>It supports very large disks and very large numbers of partitions.</li>
</ul>
<p>A GPT disk contains a primary header near the beginning of the disk,
followed by a partition entry array. The header and partition entry
array have a secondary copy at the end of the disk for redundancy. The
partition entry arrays contain structures that describe each partition,
including a GUID to identify the individual partition, a partition type
GUID to indicate the purpose of the partition, and start/end block
addresses. In between the entry arrays is the actual partition data.</p>
<h2 id="system-partition-1"><a class="header" href="#system-partition-1">System partition</a></h2>
<p>The system partition is UEFI's version of a bootable partition. The
system partition is sometimes called the ESP, or EFI System
Partition. It is identified by a partition type of
<code>c12a7328-f81f-11d2-ba4b-00a0c93ec93b</code>. The system partition always
contains a FAT file system. There are various standardized paths that
can exist within the file system, and of particular importance are the
boot files. These are the files that UEFI will try to boot from by
default (in the absence of a different boot configuration set through
special <a href="concepts/variables.html">UEFI variables</a>).</p>
<p>Boot files are under <code>\EFI\BOOT</code>, and are named <code>BOOT&lt;ARCH&gt;.efi</code>, where
<code>&lt;ARCH&gt;</code> is a short architecture name.</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>File name</th></tr></thead><tbody>
<tr><td>Intel 32-bit</td><td>BOOTIA32.EFI</td></tr>
<tr><td>X86_64</td><td>BOOTX64.EFI</td></tr>
<tr><td>Itanium</td><td>BOOTIA64.EFI</td></tr>
<tr><td>AArch32</td><td>BOOTARM.EFI</td></tr>
<tr><td>AArch64</td><td>BOOTAA64.EFI</td></tr>
<tr><td>RISC-V 32-bit</td><td>BOOTRISCV32.EFI</td></tr>
<tr><td>RISC-V 64-bit</td><td>BOOTRISCV64.EFI</td></tr>
<tr><td>RISC-V 128-bit</td><td>BOOTRISCV128.EFI</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/rustc/platform-support/unknown-uefi.html">Rust <code>*-unknown-uefi</code> targets</a></li>
<li><a href="https://docs.rs/uefi"><code>uefi</code> crate reference</a></li>
<li><a href="https://docs.rs/uefi-macros"><code>uefi-macros</code> crate reference</a></li>
<li><a href="https://docs.rs/uefi-raw"><code>uefi-raw</code> crate reference</a></li>
<li><a href="https://uefi.org/specifications">UEFI Specifications</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
