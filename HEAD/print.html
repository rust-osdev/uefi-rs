<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust UEFI Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tutorial/introduction.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/app.html"><strong aria-hidden="true">2.1.</strong> Creating a UEFI Application</a></li><li class="chapter-item expanded "><a href="tutorial/building.html"><strong aria-hidden="true">2.2.</strong> Building</a></li><li class="chapter-item expanded "><a href="tutorial/vm.html"><strong aria-hidden="true">2.3.</strong> Running in a VM</a></li><li class="chapter-item expanded "><a href="tutorial/hardware.html"><strong aria-hidden="true">2.4.</strong> Running on Hardware</a></li></ol></li><li class="chapter-item expanded "><a href="how_to/introduction.html"><strong aria-hidden="true">3.</strong> How-to</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="how_to/protocols.html"><strong aria-hidden="true">3.1.</strong> Using Protocols</a></li><li class="chapter-item expanded "><a href="how_to/drawing.html"><strong aria-hidden="true">3.2.</strong> Drawing to the Screen</a></li><li class="chapter-item expanded "><a href="how_to/building_drivers.html"><strong aria-hidden="true">3.3.</strong> Building drivers</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/introduction.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/boot_stages.html"><strong aria-hidden="true">4.1.</strong> Boot Stages</a></li><li class="chapter-item expanded "><a href="concepts/tables.html"><strong aria-hidden="true">4.2.</strong> Tables</a></li><li class="chapter-item expanded "><a href="concepts/guid.html"><strong aria-hidden="true">4.3.</strong> GUID</a></li><li class="chapter-item expanded "><a href="concepts/handles_and_protocols.html"><strong aria-hidden="true">4.4.</strong> Handles and Protocols</a></li><li class="chapter-item expanded "><a href="concepts/device_paths.html"><strong aria-hidden="true">4.5.</strong> Device Paths</a></li><li class="chapter-item expanded "><a href="concepts/variables.html"><strong aria-hidden="true">4.6.</strong> Variables</a></li><li class="chapter-item expanded "><a href="concepts/gpt.html"><strong aria-hidden="true">4.7.</strong> GPT</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">5.</strong> Reference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust UEFI Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Rust UEFI Book. The focus of this book is how to use
<a href="https://github.com/rust-osdev/uefi-rs"><code>uefi-rs</code></a> to build UEFI applications in Rust, but it also describes
some general UEFI concepts, as well as relevant tools such as QEMU.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>This tutorial describes the process of creating and running a simple
x86_64 UEFI application in Rust. The application will print &quot;Hello
World&quot;, pause for 10 seconds, then exit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-uefi-application"><a class="header" href="#creating-a-uefi-application">Creating a UEFI application</a></h1>
<h2 id="install-dependencies"><a class="header" href="#install-dependencies">Install dependencies</a></h2>
<p>Follow the <a href="https://www.rust-lang.org/tools/install">Rust installation instructions</a> to set up Rust.</p>
<h2 id="create-a-minimal-application"><a class="header" href="#create-a-minimal-application">Create a minimal application</a></h2>
<p>Create an empty application and change to that directory:</p>
<pre><code class="language-sh">cargo new my-uefi-app
cd my-uefi-app
</code></pre>
<p>Add a few dependencies:</p>
<pre><code class="language-sh">cargo add log
cargo add uefi --features logger,panic_handler
</code></pre>
<p>to your <code>Cargo.toml</code>. The resulting <code>Cargo.toml</code> should look like that:</p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4.21&quot;
uefi = { version = &quot;0.29.0&quot;, features = [ &quot;panic_handler&quot;, &quot;logger&quot; ] }
</code></pre>
<p>Replace the contents of <code>src/main.rs</code> with this:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use log::info;
use uefi::prelude::*;

#[entry]
fn main(_image_handle: Handle, mut system_table: SystemTable&lt;Boot&gt;) -&gt; Status {
    uefi::helpers::init(&amp;mut system_table).unwrap();
    info!(&quot;Hello world!&quot;);
    system_table.boot_services().stall(10_000_000);
    Status::SUCCESS
}
</code></pre></pre>
<h2 id="walkthrough"><a class="header" href="#walkthrough">Walkthrough</a></h2>
<p>Let's look a quick look at what each part of the program is doing,
starting with the <code>#![...]</code> lines at the top:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_main]
#![no_std]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>This is some boilerplate that all Rust UEFI applications will
need. <code>no_main</code> is needed because the UEFI application entry point is
different from the standard Rust <code>main</code> function. <code>no_std</code> is needed to
turn off the <code>std</code> library; the <code>core</code> and <code>alloc</code> crates can still be
used.</p>
<p>Next up are some <code>use</code> lines. Nothing too exciting here; the
<code>uefi::prelude</code> module is intended to be glob-imported, and exports a
number of commonly-used types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::info;
use uefi::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>Now we get to the UEFI application <code>main</code> function, and here things look
a little different from a standard Rust program.</p>
<pre><pre class="playground"><code class="language-rust">#[entry]
fn main(_image_handle: Handle, mut system_table: SystemTable&lt;Boot&gt;) -&gt; Status {
</code></pre></pre>
<p>The <code>main</code> function in a Uefi application always takes two arguments,
the image handle and the system table. The image <a href="tutorial/../concepts/handles_and_protocols.html">handle</a> represents the
currently-running executable, and the system <a href="tutorial/../concepts/tables.html">table</a> provides access to
many different UEFI services. The <code>main</code> function returns a <a href="https://docs.rs/uefi/latest/uefi/struct.Status.html"><code>Status</code></a>,
which is essentially a numeric error (or success) code defined by UEFI.</p>
<p>The first thing we do inside of <code>main</code> is initialize <code>uefi_services</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    uefi::helpers::init(&amp;mut system_table).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The <code>uefi_services</code> crate is not strictly required to make a UEFI
application with the <code>uefi</code> crate, but it makes things much simpler by
setting a simple memory allocator, initializing the logger, and
providing a panic handler.</p>
<p>Next we use the standard <code>log</code> crate to output &quot;Hello world!&quot;. Then we
call <code>stall</code> to make the system pause for 10 seconds. This just ensures
you have enough time to see the output.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    info!(&quot;Hello world!&quot;);
    system_table.boot_services().stall(10_000_000);
<span class="boring">}
</span></code></pre></pre>
<p>Finally we return <code>Status::SUCCESS</code> indicating that everything completed
successfully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Status::SUCCESS
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building"><a class="header" href="#building">Building</a></h1>
<h2 id="toolchain"><a class="header" href="#toolchain">Toolchain</a></h2>
<p>In order to compile for UEFI, an appropriate target must be installed. The
easiest way to set this up is using a <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">rustup toolchain file</a>. In the root of
your repository, add <code>rust-toolchain.toml</code>:</p>
<pre><code class="language-toml">[toolchain]
targets = [&quot;aarch64-unknown-uefi&quot;, &quot;i686-unknown-uefi&quot;, &quot;x86_64-unknown-uefi&quot;]
</code></pre>
<p>Here we have specified all three of the currently-supported UEFI targets; you
can remove some if you don't need them.</p>
<h2 id="build-the-application"><a class="header" href="#build-the-application">Build the application</a></h2>
<p>Run this command to build the application:</p>
<pre><code class="language-sh">cargo build --target x86_64-unknown-uefi
</code></pre>
<p>This will produce an x86-64 executable:
<code>target/x86_64-unknown-uefi/debug/my-uefi-app.efi</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-in-a-vm"><a class="header" href="#running-in-a-vm">Running in a VM</a></h1>
<h2 id="install-dependencies-1"><a class="header" href="#install-dependencies-1">Install dependencies</a></h2>
<p>Two dependencies are needed: <a href="https://www.qemu.org">QEMU</a>, which implements the virtual
machine itself, and <a href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF</a>, which provides UEFI firmware that QEMU can
run.</p>
<p>The details of how to install QEMU and OVMF will vary depending on your
operating system.</p>
<p>Debian/Ubuntu:</p>
<pre><code class="language-sh">sudo apt-get install qemu ovmf
</code></pre>
<p>Fedora:</p>
<pre><code class="language-sh">sudo dnf install qemu-kvm edk2-ovmf
</code></pre>
<h3 id="firmware-files"><a class="header" href="#firmware-files">Firmware files</a></h3>
<p>The OVMF package provides two firmware files, one for the executable
code and one for variable storage. (The package may provide multiple
variations of these files; refer to the package's documentation for
details of the files it includes.)</p>
<p>For ease of access we'll copy the OVMF code and vars files to the
project directory. The location where OVMF is installed depends on your
operating system; for Debian, Ubuntu and Fedora the files are under
<code>/usr/share/OVMF</code>.</p>
<p>Copy the files to your project directory:</p>
<pre><code class="language-sh">cp /usr/share/OVMF/OVMF_CODE.fd .
cp /usr/share/OVMF/OVMF_VARS.fd .
</code></pre>
<h2 id="system-partition"><a class="header" href="#system-partition">System partition</a></h2>
<p>Now create a directory structure containing the executable to imitate a
<a href="tutorial/../concepts/gpt.html#system-partition">UEFI System Partition</a>:</p>
<pre><code class="language-sh">mkdir -p esp/efi/boot
cp target/x86_64-unknown-uefi/debug/my-uefi-app.efi esp/efi/boot/bootx64.efi
</code></pre>
<h2 id="launch-the-vm"><a class="header" href="#launch-the-vm">Launch the VM</a></h2>
<p>Now we can launch QEMU, using <a href="https://en.m.wikibooks.org/wiki/QEMU/Devices/Storage#Virtual_FAT_filesystem_(VVFAT)">VVFAT</a> to access the <code>esp</code> directory created above.</p>
<pre><code class="language-sh">qemu-system-x86_64 -enable-kvm \
    -drive if=pflash,format=raw,readonly=on,file=OVMF_CODE.fd \
    -drive if=pflash,format=raw,readonly=on,file=OVMF_VARS.fd \
    -drive format=raw,file=fat:rw:esp
</code></pre>
<p>A QEMU window should appear, and after a few seconds you should see the
log message:</p>
<pre><code class="language-text">[ INFO]:  src/main.rs@011: Hello world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-on-hardware"><a class="header" href="#running-on-hardware">Running on Hardware</a></h1>
<p>To run on real hardware you'll need a specially-prepared USB drive.</p>
<h2 id="preparation"><a class="header" href="#preparation">Preparation</a></h2>
<p>The general steps to prepare the drive are:</p>
<ol>
<li>Partition the drive using <a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GPT</a>.</li>
<li>Create a partition.</li>
<li>Set the partition type GUID to
<code>C12A7328-F81F-11D2-BA4B-00A0C93EC93B</code>. That marks it as an EFI
System partition. (On many UEFI implementations this is not strictly
necessary, see note below.)</li>
<li>Format the partition as <a href="https://en.wikipedia.org/wiki/File_Allocation_Table">FAT</a>.</li>
<li>Mount the partition.</li>
<li>Create the directory path <code>EFI/BOOT</code> on the partition. (FAT is case
insensitive, so capitalization doesn't matter.)</li>
<li>Copy your EFI application to a file under <code>EFI/BOOT</code>. The file name
is specific to the architecture. For example, on x86_64 the file name
must be <code>BOOTX64.EFI</code>. See the <a href="tutorial/../concepts/gpt.html#system-partition">boot files</a> table for other
architectures.</li>
</ol>
<p>The details of exactly how to do these steps will vary depending on your OS.</p>
<p>Note that most UEFI implementations do not strictly require GPT
partitioning or the EFI System partition GUID; they will look for any
FAT partition with the appropriate directory structure. This is not
required however; the UEFI Specification says &quot;UEFI implementations may
allow the use of conforming FAT partitions which do not use the ESP
GUID.&quot;</p>
<h3 id="example-on-linux"><a class="header" href="#example-on-linux">Example on Linux</a></h3>
<p><strong>Warning: these operations are destructive! Do not run these commands
on a disk if you care about the data it contains.</strong></p>
<pre><code class="language-sh"># Create the GPT, create a 9MB partition starting at 1MB, and set the
# partition type to EFI System.
sgdisk \
    --clear \
    --new=1:1M:10M \
    --typecode=1:C12A7328-F81F-11D2-BA4B-00A0C93EC93B \
    /path/to/disk

# Format the partition as FAT.
mkfs.fat /path/to/disk_partition

# Mount the partition.
mkdir esp
mount /path/to/disk_partition esp

# Create the boot directory.
mkdir esp/EFI/BOOT

# Copy in the boot executable.
cp /path/to/your-executable.efi esp/EFI/BOOT/BOOTX64.EFI
</code></pre>
<h2 id="booting-the-usb"><a class="header" href="#booting-the-usb">Booting the USB</a></h2>
<p>Insert the USB into the target computer. Reboot the machine, then press
the one-time boot key. Which key to press depends on the vendor. For
example, Dell uses F12, HP uses F9, and on Macs you hold down the Option
key.</p>
<p>Once the one-time boot menu appears, select your USB drive and press enter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to"><a class="header" href="#how-to">How-to</a></h1>
<p>This chapter contains practical how-to guides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-protocols"><a class="header" href="#using-protocols">Using Protocols</a></h1>
<p>The open a protocol, you must first get a handle, then open a protocol
on that handle. See <a href="how_to/../concepts/handles_and_protocols.html">Handles and Protocols</a> for an overview of what
these terms mean.</p>
<p>To get a handle you can use:</p>
<ul>
<li><a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.locate_handle_buffer"><code>BootServices::locate_handle_buffer</code></a>: this can be used to get <em>all</em>
available handles, or just the handles that support a particular
protocol.</li>
<li><a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.locate_handle"><code>BootServices::locate_handle</code></a>: the same as <code>locate_handle_buffer</code>,
but you provide the slice that stores the handles.</li>
<li><a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.locate_device_path"><code>BootServices::locate_device_path</code></a>: find a handle by <a href="how_to/../concepts/device_paths.html">Device Path</a>.</li>
</ul>
<p>Once you have obtained a handle, use
<a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.open_protocol_exclusive"><code>BootServices::open_protocol_exclusive</code></a> to open a protocol on that
handle. This returns a <a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.ScopedProtocol.html"><code>ScopedProtocol</code></a>, which automatically closes
the protocol when dropped.</p>
<p>Using <a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.open_protocol_exclusive"><code>BootServices::open_protocol_exclusive</code></a> is the safest way to
open a protocol, but in some cases a protocol cannot be opened in
exclusive mode. The <code>unsafe</code> <a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.open_protocol"><code>BootServices::open_protocol</code></a> can be used
in that case.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>For this example we'll look at a program that opens a couple different
protocols. This program opens the <a href="https://docs.rs/uefi/latest/uefi/proto/loaded_image/struct.LoadedImage.html"><code>LoadedImage</code></a> protocol to get
information about an executable (the currently-running program in this
case). It also opens the <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/text/struct.DevicePathToText.html"><code>DevicePathToText</code></a> protocol to get the file
system path that the program was launched from.</p>
<p>We'll walk through the details of this program shortly, but first here's
the whole thing:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

use log::info;
use uefi::prelude::*;
use uefi::proto::device_path::text::{
    AllowShortcuts, DevicePathToText, DisplayOnly,
};
use uefi::proto::loaded_image::LoadedImage;
use uefi::table::boot::SearchType;
use uefi::{Identify, Result};

#[entry]
fn main(image_handle: Handle, mut system_table: SystemTable&lt;Boot&gt;) -&gt; Status {
    uefi::helpers::init(&amp;mut system_table).unwrap();
    let boot_services = system_table.boot_services();

    print_image_path(boot_services).unwrap();

    boot_services.stall(10_000_000);
    Status::SUCCESS
}

fn print_image_path(boot_services: &amp;BootServices) -&gt; Result {
    let loaded_image = boot_services
        .open_protocol_exclusive::&lt;LoadedImage&gt;(boot_services.image_handle())?;

    let device_path_to_text_handle = *boot_services
        .locate_handle_buffer(SearchType::ByProtocol(&amp;DevicePathToText::GUID))?
        .first()
        .expect(&quot;DevicePathToText is missing&quot;);

    let device_path_to_text = boot_services
        .open_protocol_exclusive::&lt;DevicePathToText&gt;(
            device_path_to_text_handle,
        )?;

    let image_device_path =
        loaded_image.file_path().expect(&quot;File path is not set&quot;);
    let image_device_path_text = device_path_to_text
        .convert_device_path_to_text(
            boot_services,
            image_device_path,
            DisplayOnly(true),
            AllowShortcuts(false),
        )
        .expect(&quot;convert_device_path_to_text failed&quot;);

    info!(&quot;Image path: {}&quot;, &amp;*image_device_path_text);
    Ok(())
}
</code></pre></pre>
<p>When the program is run it will print something like this:</p>
<pre><code class="language-text">[ INFO]: example.rs@058: Image path: \EFI\BOOT\BOOTX64.EFI
</code></pre>
<h2 id="walkthrough-1"><a class="header" href="#walkthrough-1">Walkthrough</a></h2>
<p>The <code>main</code> function looks much like the <a href="how_to/../tutorial/app.html">&quot;Hello world!&quot; example</a>. It
sets up logging, calls <code>print_image_path</code>, and pauses for ten seconds to
give you time to read the output. Let's look at <code>print_image_path</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_image_path(boot_services: &amp;BootServices) -&gt; Result {
<span class="boring">}
</span></code></pre></pre>
<p>The return type is a <a href="https://docs.rs/uefi/latest/uefi/type.Result.html"><code>uefi::Result</code></a>, which is a <code>Result</code> alias that
combines <a href="https://docs.rs/uefi/latest/uefi/struct.Status.html"><code>uefi::Status</code></a> with the error data. Both the success and
error data types are <code>()</code> by default.</p>
<p>The function starts by opening the <a href="https://docs.rs/uefi/latest/uefi/proto/loaded_image/struct.LoadedImage.html"><code>LoadedImage</code></a> protocol:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let loaded_image = boot_services
        .open_protocol_exclusive::&lt;LoadedImage&gt;(boot_services.image_handle())?;
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.open_protocol_exclusive"><code>open_protocol_exclusive</code></a> method takes a type parameter, which is
the type of <a href="https://docs.rs/uefi/latest/uefi/proto/trait.Protocol.html"><code>Protocol</code></a> you want to open (<a href="https://docs.rs/uefi/latest/uefi/proto/loaded_image/struct.LoadedImage.html"><code>LoadedImage</code></a> in this
case). It also takes one regular argument of type <a href="https://docs.rs/uefi/latest/uefi/data_types/struct.Handle.html"><code>Handle</code></a>. For this
example we want the handle of the currently-running image, which was
passed in as the first argument to <code>main</code>. The handle is conveniently
accessible through <a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.image_handle"><code>BootServices::image_handle</code></a>, so we use that here.</p>
<p>Next the program opens the <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/text/struct.DevicePathToText.html"><code>DevicePathToText</code></a> protocol:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let device_path_to_text_handle = *boot_services
        .locate_handle_buffer(SearchType::ByProtocol(&amp;DevicePathToText::GUID))?
        .first()
        .expect(&quot;DevicePathToText is missing&quot;);

    let device_path_to_text = boot_services
        .open_protocol_exclusive::&lt;DevicePathToText&gt;(
            device_path_to_text_handle,
        )?;
<span class="boring">}
</span></code></pre></pre>
<p>This protocol isn't available for the <code>image_handle</code>, so we start by
using <a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.locate_handle_buffer"><code>locate_handle_buffer</code></a> to find all handles that support
<code>DevicePathToText</code>. We only need one handle though, so we call <code>first()</code>
and discard the rest. Then we call <a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html#method.open_protocol_exclusive"><code>open_protocol_exclusive</code></a> again. It
looks more or less like the previous time, but with <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/text/struct.DevicePathToText.html"><code>DevicePathToText</code></a>
as the type parameter and <code>device_path_to_text_handle</code> as the handle.</p>
<p>Now that we have both protocols open, we can use them together to get
the program's path and convert it to text:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let image_device_path =
        loaded_image.file_path().expect(&quot;File path is not set&quot;);
    let image_device_path_text = device_path_to_text
        .convert_device_path_to_text(
            boot_services,
            image_device_path,
            DisplayOnly(true),
            AllowShortcuts(false),
        )
        .expect(&quot;convert_device_path_to_text failed&quot;);

    info!(&quot;Image path: {}&quot;, &amp;*image_device_path_text);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Since protocols do a wide range of different things, the methods
available to call are very specific to each individual protocol. The
best places to find out what each protocol can do are the <a href="https://docs.rs/uefi/latest/uefi/proto/index.html">uefi-rs
reference documentation</a> and the <a href="https://uefi.org/specifications">UEFI Specification</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-to-the-screen"><a class="header" href="#drawing-to-the-screen">Drawing to the Screen</a></h1>
<p>This example shows how to draw to the screen using the <a href="https://docs.rs/uefi/latest/uefi/proto/console/gop/index.html">graphics output protocol</a>.
The code will a <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle#Chaos_game">Sierpi≈Ñski triangle</a> using the &quot;chaos game&quot; method.</p>
<p><img src="https://i.imgur.com/0tpjtV6.png" alt="screenshot" /></p>
<p>The core abstraction used here is a linear buffer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Buffer {
    width: usize,
    height: usize,
    pixels: Vec&lt;BltPixel&gt;,
}

impl Buffer {
    /// Create a new `Buffer`.
    fn new(width: usize, height: usize) -&gt; Self {
        Buffer {
            width,
            height,
            pixels: vec![BltPixel::new(0, 0, 0); width * height],
        }
    }

    /// Get a single pixel.
    fn pixel(&amp;mut self, x: usize, y: usize) -&gt; Option&lt;&amp;mut BltPixel&gt; {
        self.pixels.get_mut(y * self.width + x)
    }

    /// Blit the buffer to the framebuffer.
    fn blit(&amp;self, gop: &amp;mut GraphicsOutput) -&gt; Result {
        gop.blt(BltOp::BufferToVideo {
            buffer: &amp;self.pixels,
            src: BltRegion::Full,
            dest: (0, 0),
            dims: (self.width, self.height),
        })
    }

    /// Update only a pixel to the framebuffer.
    fn blit_pixel(
        &amp;self,
        gop: &amp;mut GraphicsOutput,
        coords: (usize, usize),
    ) -&gt; Result {
        gop.blt(BltOp::BufferToVideo {
            buffer: &amp;self.pixels,
            src: BltRegion::SubRectangle {
                coords,
                px_stride: self.width,
            },
            dest: coords,
            dims: (1, 1),
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This <code>Buffer</code> type stores a <code>Vec</code> of <a href="https://docs.rs/uefi/latest/uefi/proto/console/gop/struct.BltPixel.html"><code>BltPixel</code></a>s, which are BGRX
32-bit pixels (8 bites each for blue, green, and red, followed by 8
unused bits of padding). We use the <code>pixel</code> method to alter a single
pixel at a time. This is often not an efficient method; for more complex
graphics you could use a crate like <a href="https://crates.io/crates/embedded-graphics"><code>embedded-graphics</code></a>.</p>
<p>The <code>Buffer::blit</code> method calls the graphics output protocol's <code>blt</code>
method to copy the buffer to the screen.</p>
<p>Most of the rest of the code is just implementing the algorithm for
drawing the fractal. Here's the full example:</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

extern crate alloc;

use alloc::vec;
use alloc::vec::Vec;
use core::mem;
use uefi::prelude::*;
use uefi::proto::console::gop::{BltOp, BltPixel, BltRegion, GraphicsOutput};
use uefi::proto::rng::Rng;
use uefi::Result;

#[derive(Clone, Copy)]
struct Point {
    x: f32,
    y: f32,
}

impl Point {
    fn new(x: f32, y: f32) -&gt; Self {
        Self { x, y }
    }
}

struct Buffer {
    width: usize,
    height: usize,
    pixels: Vec&lt;BltPixel&gt;,
}

impl Buffer {
    /// Create a new `Buffer`.
    fn new(width: usize, height: usize) -&gt; Self {
        Buffer {
            width,
            height,
            pixels: vec![BltPixel::new(0, 0, 0); width * height],
        }
    }

    /// Get a single pixel.
    fn pixel(&amp;mut self, x: usize, y: usize) -&gt; Option&lt;&amp;mut BltPixel&gt; {
        self.pixels.get_mut(y * self.width + x)
    }

    /// Blit the buffer to the framebuffer.
    fn blit(&amp;self, gop: &amp;mut GraphicsOutput) -&gt; Result {
        gop.blt(BltOp::BufferToVideo {
            buffer: &amp;self.pixels,
            src: BltRegion::Full,
            dest: (0, 0),
            dims: (self.width, self.height),
        })
    }

    /// Update only a pixel to the framebuffer.
    fn blit_pixel(
        &amp;self,
        gop: &amp;mut GraphicsOutput,
        coords: (usize, usize),
    ) -&gt; Result {
        gop.blt(BltOp::BufferToVideo {
            buffer: &amp;self.pixels,
            src: BltRegion::SubRectangle {
                coords,
                px_stride: self.width,
            },
            dest: coords,
            dims: (1, 1),
        })
    }
}

/// Get a random `usize` value.
fn get_random_usize(rng: &amp;mut Rng) -&gt; usize {
    let mut buf = [0; mem::size_of::&lt;usize&gt;()];
    rng.get_rng(None, &amp;mut buf).expect(&quot;get_rng failed&quot;);
    usize::from_le_bytes(buf)
}

fn draw_sierpinski(bt: &amp;BootServices) -&gt; Result {
    // Open graphics output protocol.
    let gop_handle = bt.get_handle_for_protocol::&lt;GraphicsOutput&gt;()?;
    let mut gop = bt.open_protocol_exclusive::&lt;GraphicsOutput&gt;(gop_handle)?;

    // Open random number generator protocol.
    let rng_handle = bt.get_handle_for_protocol::&lt;Rng&gt;()?;
    let mut rng = bt.open_protocol_exclusive::&lt;Rng&gt;(rng_handle)?;

    // Create a buffer to draw into.
    let (width, height) = gop.current_mode_info().resolution();
    let mut buffer = Buffer::new(width, height);

    // Initialize the buffer with a simple gradient background.
    for y in 0..height {
        let r = ((y as f32) / ((height - 1) as f32)) * 255.0;
        for x in 0..width {
            let g = ((x as f32) / ((width - 1) as f32)) * 255.0;
            let pixel = buffer.pixel(x, y).unwrap();
            pixel.red = r as u8;
            pixel.green = g as u8;
            pixel.blue = 255;
        }
    }

    // Draw background.
    buffer.blit(&amp;mut gop)?;

    let size = Point::new(width as f32, height as f32);

    // Define the vertices of a big triangle.
    let border = 20.0;
    let triangle = [
        Point::new(size.x / 2.0, border),
        Point::new(border, size.y - border),
        Point::new(size.x - border, size.y - border),
    ];

    // `p` is the point to draw. Start at the center of the triangle.
    let mut p = Point::new(size.x / 2.0, size.y / 2.0);

    // Loop forever, drawing the frame after each new point is changed.
    loop {
        // Choose one of the triangle's vertices at random.
        let v = triangle[get_random_usize(&amp;mut rng) % 3];

        // Move `p` halfway to the chosen vertex.
        p.x = (p.x + v.x) * 0.5;
        p.y = (p.y + v.y) * 0.5;

        // Set `p` to black.
        let pixel = buffer.pixel(p.x as usize, p.y as usize).unwrap();
        pixel.red = 0;
        pixel.green = 100;
        pixel.blue = 0;

        // Draw the buffer to the screen.
        buffer.blit_pixel(&amp;mut gop, (p.x as usize, p.y as usize))?;
    }
}

#[entry]
fn main(_handle: Handle, mut system_table: SystemTable&lt;Boot&gt;) -&gt; Status {
    uefi::helpers::init(&amp;mut system_table).unwrap();
    let bt = system_table.boot_services();
    draw_sierpinski(bt).unwrap();
    Status::SUCCESS
}
</code></pre></pre>
<p>You can run this example from the <a href="https://github.com/rust-osdev/uefi-rs">uefi-rs</a> repository with:</p>
<pre><code class="language-console">cargo xtask run --example sierpinski
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-drivers"><a class="header" href="#building-drivers">Building drivers</a></h1>
<p>There are <a href="https://uefi.org/specs/UEFI/2.10/02_Overview.html#uefi-images">three types</a> of UEFI images:</p>
<ul>
<li>Application</li>
<li>Boot service driver</li>
<li>Runtime driver</li>
</ul>
<p><a href="https://github.com/rust-lang/rust/blob/f4d794ea0b845413344621d89f6c945062748485/compiler/rustc_target/src/spec/base/uefi_msvc.rs#L33">By default</a>, Rust's UEFI targets produce applications. This can be
changed by passing a <a href="https://learn.microsoft.com/en-us/cpp/build/reference/subsystem?view=msvc-170"><code>subsystem</code></a> linker flag in <code>rustflags</code> and setting the
value to <code>efi_boot_service_driver</code> or <code>efi_runtime_driver</code>.</p>
<p>Example:</p>
<pre><code class="language-toml"># In .cargo/config.toml:
[build]
rustflags = [&quot;-C&quot;, &quot;link-args=/subsystem:efi_runtime_driver&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>The canonical source of information about UEFI is the <a href="https://uefi.org/specifications">UEFI specification</a>.
The specification is huge (currently nearly 2500 pages). Much of that
content relates to optional services, understanding of which is not
critical to understanding UEFI as a whole. This chapter summarizes some
of the more important UEFI concepts and links to the relevant <code>uefi-rs</code>
documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boot-stages"><a class="header" href="#boot-stages">Boot Stages</a></h1>
<p>A UEFI system goes through several distinct phases during the boot process.</p>
<ol>
<li><strong>Platform Initialization.</strong> This early-boot phase is mostly outside
the scope of <code>uefi-rs</code>. It is described by the <a href="https://uefi.org/specifications">UEFI Platform
Initialization Specification</a>, which is separate from the main UEFI
Specification.</li>
<li><strong>Boot Services.</strong> This is when UEFI drivers and applications are
loaded. Both the <a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html"><code>BootServices</code></a> and <a href="https://docs.rs/uefi/latest/uefi/table/runtime/struct.RuntimeServices.html"><code>RuntimeServices</code></a> tables are
accessible. This stage typically culminates in running a bootloader
that loads an operating system. The stage ends when
<a href="https://docs.rs/uefi/latest/uefi/table/struct.SystemTable.html#method.exit_boot_services"><code>SystemTable::exit_boot_services</code></a> is called, putting the system in
Runtime mode.</li>
<li><strong>Runtime.</strong> This stage is typically active when running an operating
system such as Linux or Windows. UEFI functionality is much more
limited in the Runtime mode. The <a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html"><code>BootServices</code></a> table is no longer
accessible, but the <a href="https://docs.rs/uefi/latest/uefi/table/runtime/struct.RuntimeServices.html"><code>RuntimeServices</code></a> table is still
available. Once the system is in Runtime mode, it cannot return to
the Boot Services stage until after a system reset.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tables"><a class="header" href="#tables">Tables</a></h1>
<p>UEFI has a few table structures. These tables are how you get access to
UEFI services.</p>
<p><a href="https://docs.rs/uefi/latest/uefi/table/struct.SystemTable.html"><code>SystemTable</code></a> (<code>EFI_SYSTEM_TABLE</code> in the specification) is the
top-level table that provides access to the other tables.</p>
<p><a href="https://docs.rs/uefi/latest/uefi/table/boot/struct.BootServices.html"><code>BootServices</code></a> (<code>EFI_BOOT_SERVICES</code> in the specification) provides
access to a wide array of services such as memory allocation, executable
loading, and optional extension interfaces called protocols. This table
is only accessible while in the Boot Services stage.</p>
<p><a href="https://docs.rs/uefi/latest/uefi/table/runtime/struct.RuntimeServices.html"><code>RuntimeServices</code></a> (<code>EFI_RUNTIME_SERVICES</code> in the specification)
provides access to a fairly limited set of services, including variable
storage, system time, and virtual-memory mapping. This table is
accessible during both the Boot Services and Runtime stages.</p>
<p>When writing a UEFI application, you get access to the system table from
one of the arguments to the <code>main</code> entry point:</p>
<pre><code class="language-rust ignore">fn main(handle: Handle, mut system_table: SystemTable&lt;Boot&gt;) -&gt; Status;
</code></pre>
<p>Then use <a href="https://docs.rs/uefi/latest/uefi/table/struct.SystemTable.html#method.boot_services"><code>SystemTable::boot_services</code></a> and
<a href="https://docs.rs/uefi/latest/uefi/table/struct.SystemTable.html#method.runtime_services"><code>SystemTable::runtime_services</code></a> to get access to the other
tables. Once <a href="https://docs.rs/uefi/latest/uefi/table/struct.SystemTable.html#method.exit_boot_services"><code>SystemTable::exit_boot_services</code></a> is called, the original
system table is consumed and a new system table is returned that only
provides access to the <a href="https://docs.rs/uefi/latest/uefi/table/runtime/struct.RuntimeServices.html"><code>RuntimeServices</code></a> table.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guid"><a class="header" href="#guid">GUID</a></h1>
<p>GUID is short for Globally Unique Identifier. A GUID is always 16 bytes,
and has a standard string representation format that looks like this:
<code>313b0d7c-fed4-4de7-99ed-2fe48874a410</code>. The details of the GUID format
aren't too important, but be aware that the actual byte representation
is not in the same order as the string representation because the first
three fields are little-endian. For the most part you can treat GUIDs as
opaque identifiers.</p>
<p>The UEFI specification uses GUIDs all over the place. GUIDs are used to
identify protocols, disk partitions, variable groupings, and much
more. In <code>uefi-rs</code>, GUIDs are represented by the <a href="https://docs.rs/uefi/latest/uefi/struct.Guid.html"><code>Guid</code></a> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handles-and-protocols"><a class="header" href="#handles-and-protocols">Handles and Protocols</a></h1>
<p>Handles and protocols are at the core of what makes UEFI
extensible. Together they are the mechanism by which UEFI can adapt to a
wide array of hardware and boot conditions, while still providing a
consistent interface to drivers and applications.</p>
<h3 id="handles"><a class="header" href="#handles">Handles</a></h3>
<p>Handles represent resources. A resource might be a physical device such
as a disk drive or USB device, or something less tangible like a loaded
executable. </p>
<p>A <a href="https://docs.rs/uefi/latest/uefi/data_types/struct.Handle.html">Handle</a> is an opaque pointer, so you can't do anything with it
directly. To operate on a handle you have to open a protocol. </p>
<h3 id="protocols"><a class="header" href="#protocols">Protocols</a></h3>
<p>Protocols are interfaces that provide functions to interact with a
resource. For example, the <a href="https://docs.rs/uefi/latest/uefi/proto/media/block/struct.BlockIO.html">BlockIO</a> protocol provides functions to read
and write to block IO devices.</p>
<p>Protocols are only available during the Boot Services <a href="concepts/boot_stages.html">stage</a>; you can't
access them during the Runtime stage.</p>
<p>The UEFI Specification defines a very large number of protocols. Because
protocols are inherently very diverse, the best place to learn about
individual protocols is the <a href="https://uefi.org/specifications">UEFI Specification</a>. There are many
chapters covering various protocols. Not all of these protocols are
wrapped by <code>uefi-rs</code> yet (contributions welcome!) but many of the most
commonly useful ones are.</p>
<p>See the <a href="concepts/../how_to/protocols.html">Using Protocols</a> how-to for details of the <code>uefi-rs</code> API for
interacting with protocols.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-paths"><a class="header" href="#device-paths">Device Paths</a></h1>
<p>A device path is a very flexible packed data structure for storing paths
to many kinds of device. Note that these device paths are not the same
thing as file system paths, although they can include file system
paths. Like <a href="concepts/handles_and_protocols.html">handles</a>, device paths can be used to uniquely identify
resources such as consoles, mice, disks, partitions, and more. Unlike
<a href="concepts/handles_and_protocols.html">handles</a>, which are essentially opaque pointers, device paths are
variable-length structures that contain parseable information.</p>
<p>The <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/index.html"><code>uefi::proto::device_path</code></a> module documentation describes the
details of how device paths are encoded.</p>
<p>Device paths can also be converted to and from human-readable text
representations that look like this:</p>
<pre><code class="language-text">PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)
</code></pre>
<p>See <a href="https://docs.rs/uefi/latest/uefi/proto/device_path/text/index.html"><code>uefi::proto::device_path::text</code></a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>UEFI provides fairly flexible key/value variable storage.</p>
<p>Each variable is identified by a key consisting of a UCS-2
null-terminated name plus a vendor <a href="concepts/guid.html">GUID</a>. The vendor GUID serves as a
namespace for variables so that different vendors don't accidentally
overwrite or misinterpret another vendor's variable if they happen to
have the same name.</p>
<p>The data stored in each variable is an arbitrary byte array.</p>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<p>Each variable has attributes (represented as bit flags) associated with
it that affect how it is stored and how it can be accessed.</p>
<p>If the <code>BOOTSERVICE_ACCESS</code> and <code>RUNTIME_ACCESS</code> bits are set, the
variable can be accessed during both the Boot Services and Runtime
<a href="concepts/boot_stages.html">stages</a>. If only <code>BOOTSERVICE_ACCESS</code> is set then the variable can
neither be read nor written to after exiting boot services.</p>
<p>Another important attribute is the <code>NON_VOLATILE</code> bit. If this bit is
<em>not</em> set, the variable will be stored in normal memory and will not
persist across a power cycle. If this bit <em>is</em> set, the variable will be
stored in special non-volatile memory. You should be careful about
writing variables of this type, because the non-volatile storage can be
very limited in size. There have been cases where a vendor's poor UEFI
implementation caused the machine not too boot once the storage became
too full. Even figuring out how much space is in use can be tricky due
to deletion being implemented via garbage collection. Matthew Garret's
article <a href="https://mjg59.dreamwidth.org/25091.html">&quot;Dealing with UEFI non-volatile memory quirks&quot;</a> has more details.</p>
<p>Most of the other attributes relate to authenticated variables, which
can be used to prevent changes to a variable by unauthorized programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gpt"><a class="header" href="#gpt">GPT</a></h1>
<p><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GPT</a> is short for <a href="concepts/guid.html">GUID</a> Partition Table. It's a more modern
alternative to MBR (master boot record) partition tables. Although it's
defined in the UEFI specification, it often gets used on non-UEFI
systems too. There are a couple big advantages of using GPT over MBR:</p>
<ul>
<li>It has a relatively clear and precise standard, unlike MBR where
implementations often just try to match what other implementations do.</li>
<li>It supports very large disks and very large numbers of partitions.</li>
</ul>
<p>A GPT disk contains a primary header near the beginning of the disk,
followed by a partition entry array. The header and partition entry
array have a secondary copy at the end of the disk for redundancy. The
partition entry arrays contain structures that describe each partition,
including a GUID to identify the individual partition, a partition type
GUID to indicate the purpose of the partition, and start/end block
addresses. In between the entry arrays is the actual partition data.</p>
<h2 id="system-partition-1"><a class="header" href="#system-partition-1">System partition</a></h2>
<p>The system partition is UEFI's version of a bootable partition. The
system partition is sometimes called the ESP, or EFI System
Partition. It is identified by a partition type of
<code>c12a7328-f81f-11d2-ba4b-00a0c93ec93b</code>. The system partition always
contains a FAT file system. There are various standardized paths that
can exist within the file system, and of particular importance are the
boot files. These are the files that UEFI will try to boot from by
default (in the absence of a different boot configuration set through
special <a href="concepts/variables.html">UEFI variables</a>).</p>
<p>Boot files are under <code>\EFI\BOOT</code>, and are named <code>BOOT&lt;ARCH&gt;.efi</code>, where
<code>&lt;ARCH&gt;</code> is a short architecture name.</p>
<div class="table-wrapper"><table><thead><tr><th>Architecture</th><th>File name</th></tr></thead><tbody>
<tr><td>Intel 32-bit</td><td>BOOTIA32.EFI</td></tr>
<tr><td>X86_64</td><td>BOOTX64.EFI</td></tr>
<tr><td>Itanium</td><td>BOOTIA64.EFI</td></tr>
<tr><td>AArch32</td><td>BOOTARM.EFI</td></tr>
<tr><td>AArch64</td><td>BOOTAA64.EFI</td></tr>
<tr><td>RISC-V 32-bit</td><td>BOOTRISCV32.EFI</td></tr>
<tr><td>RISC-V 64-bit</td><td>BOOTRISCV64.EFI</td></tr>
<tr><td>RISC-V 128-bit</td><td>BOOTRISCV128.EFI</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/rustc/platform-support/unknown-uefi.html">Rust <code>*-unknown-uefi</code> targets</a></li>
<li><a href="https://docs.rs/uefi"><code>uefi</code> crate reference</a></li>
<li><a href="https://docs.rs/uefi-macros"><code>uefi-macros</code> crate reference</a></li>
<li><a href="https://docs.rs/uefi-raw"><code>uefi-raw</code> crate reference</a></li>
<li><a href="https://uefi.org/specifications">UEFI Specifications</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
